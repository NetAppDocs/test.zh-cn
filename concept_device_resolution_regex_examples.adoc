---
sidebar: sidebar 
permalink: concept_device_resolution_regex_examples.html 
keywords: Automatic, AR, AHR, Host, automatic device resolution, FC, Identify, regex, expressions 
summary:  
---
= 正则表达式示例
:allow-uri-read: 


[role="lead"]
如果您选择正则表达式方法作为源命名策略，则可以使用正则表达式示例作为在 Cloud Insights 自动解析方法中使用的表达式的参考。



=== 设置正则表达式的格式

在为 Cloud Insights 自动解析创建正则表达式时，您可以通过在名为 _format_ 的字段中输入值来配置输出格式。

默认设置为 \1 ，这意味着与正则表达式匹配的分区名称将替换为正则表达式创建的第一个变量的内容。在正则表达式中，变量值由括号语句创建。如果出现多个括号语句，则变量将从左到右以数字形式引用。这些变量可以按任意顺序以输出格式使用。通过将常量文本添加到格式字段，也可以在输出中插入常量文本。

例如，根据此分区命名约定，您可能具有以下分区名称：

 [Zone number]_[data center]_[hostname]_[device type]_[interface number]
* S123_Miami_hostname1_filer_fc1
* S14_Tampa_hostname2_switch_FC4
* S3991_Boston_hostname3_windows2K_FC0
* S44_Raleigh_hostname4_solaris FC1


您可能希望输出采用以下格式：

 [hostname]-[data center]-[device type]
为此，您需要捕获变量中的主机名，数据中心和设备类型字段，并在输出中使用它们。以下正则表达式将执行此操作：

 .*?_([a-zA-Z0-9]+)_([a-zA-Z0-9]+)_([a-zA-Z0-9]+)_.*
由于有三组圆括号，因此会填充变量 \1 ， \2 和 \3 。

然后，您可以使用以下格式以首选格式接收输出：

 \2-\1-\3
您的输出如下所示：

....
hostname1-Miami-filer
hostname2-Tampa-switch
hostname3-Boston-windows2K
hostname4-Raleigh-solaris
....
变量之间的连字符提供了一个在格式化输出中插入的常量文本示例。



=== 显示分区名称的示例 1

在此示例中，您可以使用正则表达式从分区名称中提取主机名。如果您具有类似于以下分区名称的内容，则可以创建正则表达式：

* S0032_myComputer1Name-HBA0
* S0434_myComputer1Name-HBA1
* S0432_myComputer1Name-HBA3


可用于捕获主机名的正则表达式为：

 S[0-9]+_([a-zA-Z0-9]*)[_-]HBA[0-9]
结果将匹配以 S 开头的所有分区，后跟任意数字组合，下划线，字母数字主机名（ myComputer1Name ），下划线或连字符，大写字母 HBA 和单个数字（ 0-9 ）。主机名单独存储在 * 。 \1* 变量中。

正则表达式可以分为以下几个部分：

* "s" 表示分区名称并开始表达式。这仅与分区名称开头的 "S" 匹配。
* 方括号中的字符 [0-9" 表示 "S" 后面的数字必须介于 0 到 9 之间（包括 0 到 9 ）。
* 符号 + 表示前面括号中的信息必须存在 1 次或更多次。
* （下划线）表示 S 后面的数字必须紧跟在分区名称中只有下划线字符。在此示例中，分区命名约定使用下划线将分区名称与主机名分隔开。
* 在所需下划线之后，圆括号表示中包含的模式将存储在 \1 变量中。
* 括号内的字符 [a-zA-Z0-9] 表示要匹配的字符全部为字母（无论大小写如何）和数字。
* 方括号后面的 * （星号）表示括号内的字符出现 0 次或更多次。
* 带括号的字符（下划线和短划线）表示字母数字模式后面必须有下划线或短划线。
* 正则表达式中的字母 HBA 表示分区名称必须包含此字符序列。
* 最后一组带括号的字符 [0-9] 与 0 到 9 之间的一个数字（包括 0 到 9 ）匹配。




=== 示例 2.

在此示例中，跳到第一个下划线 "_" ，然后将 E 以及此后的所有内容匹配到第二个 "_" ，然后跳过之后的所有内容。

* 分区： * Z_E2FHDBS01_E1NETAPP

* 主机名： * E2FHDBS01

* 注册时间： * .* ？ _ （ e* ？） _.* ？



=== 示例 3

正则表达式（下方）最后一部分的圆括号（）用于标识主机名的部分。如果希望 VSAN3 成为主机名，则应为： [a-zA-Z0-9]+_ （ [a-zA-Z0-9]+ ）。 *

* 分区： * A_VSAN3_SR48KENT_A_CX2578_SPA0

* 主机名： * SR48KENT

* 注册时间： * [a-zA-Z0-9]+_[a-zA-Z0-9]+_ （ [a-zA-Z0-9]+ ）。 *



=== 示例 4 显示了一个更复杂的命名模式

如果您具有类似于以下分区名称的内容，则可以创建正则表达式：

* myComputerName123-HBA1_Symm1_FA3
* myComputerName123-HBA2_Symm1_FA5
* myComputerName123-HBA3_Symm1_FA7


可用于捕获这些数据的正则表达式如下：

 ([a-zA-Z0-9]*)_.*
在使用此表达式进行评估后， \1 变量将仅包含 _myComputerName123_ 。

正则表达式可以分为以下几个部分：

* 圆括号表示中包含的模式将存储在 \1 变量中。
* 括号内的字符 [a-zA-Z0-9" 表示任何字母（无论大小写）或数字都匹配。
* 方括号后面的 * （星号）表示括号内的字符出现 0 次或更多次。
* 正则表达式中的 _ （下划线）字符表示分区名称必须在与前面的方括号匹配的字母数字字符串后面紧跟一个下划线。
* 。（句点）匹配任意字符（通配符）。
* （星号）表示前一句点通配符可能出现 0 次或更多次。
+
换言之，组合 .* 表示任意字符，任意次数。





=== 示例 5 ：显示无模式的分区名称

如果您具有类似于以下分区名称的内容，则可以创建正则表达式：

* myComputerName_HBA1_Symm1_FA1
* myComputerName123_HBA1_Symm1_FA1


可用于捕获这些数据的正则表达式如下：

 (.*?)_.*
1 变量将包含 _myComputerName_ （在第一个分区名称示例中）或 _myComputerName123_ （在第二个分区名称示例中）。因此，此正则表达式将与第一个下划线之前的所有内容匹配。

正则表达式可以分为以下几个部分：

* 圆括号表示中包含的模式将存储在 \1 变量中。
* * （句点星号）可匹配任意字符，任意次数。
* 方括号后面的 * （星号）表示括号内的字符出现 0 次或更多次。
* 。字符使匹配成为非聚合。这会强制其在第一个下划线处停止匹配，而不是在最后一个下划线处停止匹配。
* 字符 _.* 与找到的第一个下划线及其后面的所有字符匹配。




=== 示例 6 ：显示具有模式的计算机名称

如果您具有类似于以下分区名称的内容，则可以创建正则表达式：

* storage1_Switch1_myComputerName123A_A1_FC1
* Storage2_Switch2_myComputerName123B_A2_FC2
* Storage3_Switch3_myComputerName123T_A3_FC3


可用于捕获这些数据的正则表达式如下：

 .*?_.*?_([a-zA-Z0-9]*[ABT])_.*
由于分区命名约定包含更多模式，因此我们可以使用上述表达式，该表达式将匹配以 A ， B 或 T 结尾的主机名（示例中为 myComputerName ）的所有实例，并将该主机名置于 \1 变量中。

正则表达式可以分为以下几个部分：

* * （句点星号）可匹配任意字符，任意次数。
* 。字符使匹配成为非聚合。这会强制其在第一个下划线处停止匹配，而不是在最后一个下划线处停止匹配。
* 下划线字符与分区名称中的第一个下划线匹配。
* 因此，第一个 .* ？ _ 组合与第一个分区名称示例中的字符 storage1_ 匹配。
* 第二个 .* ？ _ 组合的行为与第一个类似，但与第一个分区名称示例中的 Switch1_ 匹配。
* 圆括号表示中包含的模式将存储在 \1 变量中。
* 括号内的字符 [a-zA-Z0-9" 表示任何字母（无论大小写）或数字都匹配。
* 方括号后面的 * （星号）表示括号内的字符出现 0 次或更多次。
* 正则表达式（ ABT ）中的括号字符与分区名称中的一个字符匹配，该字符必须为 A ， B 或 T
* 圆括号后面的 _ （下划线）表示必须在下划线后面加上一个字符匹配项。
* * （句点星号）可匹配任意字符，任意次数。


因此，此操作的结果将使 \1 变量发生原因为包含以下任意字母数字字符串：

* 前面有一定数量的字母数字字符和两个下划线
* 后面是下划线（然后是任意数量的字母数字字符）
* 在第三个下划线之前，最后一个字符为 A ， B 或 T 。




=== 示例 7

* 分区： * myComputerName123_HBA1_Symm1_FA1

* 主机名： * myComputerName123

* 正则表达式： * （ [a-zA-Z0-9]+ ） _.*



=== 示例 8

此示例将查找第一个 _ 之前的所有内容。

分区： MyComputerName_HBA1_Symm1_FA1

MyComputerName123_HBA1_Symm1_FA1

主机名： MyComputerName

regexp ：（ .* ？） _.*

示例 9 此示例将查找第一个 _ 到第二个 _ 之后的所有内容。

* 分区： * Z_MyComputerName_StorageName

* 主机名： * MyComputerName

* 注册时间： * .* ？ _ （ .* ？） _.* ？



=== 示例 10

此示例从分区示例中提取 MyComputerName123 。

* 分区： * storage1_Switch1_MyComputerName123A_A1_FC1

Storage2_Switch2_MyComputerName123B_A2_FC2

Storage3_Switch3_MyComputerName123T_A3_FC3

* 主机名： * MyComputerName123

* 注册时间： * .* ？ _.* ？ _ （ [a-zA-Z0-9]+ ） *



=== 示例 11

* 分区： * storage1_Switch1_MyComputerName123A_A1_FC1

* 主机名： * MyComputerName123A

* 注册时间： * .* ？ _.* ？ _ （ [a-zA-Z0-9]+ ） _.* ？ _



=== 示例 12

^ （周长或记号） * 内方括号 * 将否定表达式，例如， [^FF] 表示除大写或小写 F 以外的任何内容，而 [^a-z] 表示除小写 a 到 z 以外的所有内容，在上述情况下，除 _ 以外的任何内容。format 语句将 "-" 添加到输出主机名中。

* 分区： * mhs_apps44_d_A_10a0_0429

* 主机名： * mhs-apps44-d

* 格式： * （^ _]+ ） _ （^ ） .* 格式（在 Cloud Insights 中）： \1-\2 （ [^ _]+ ） _ （^ _]+ ） _ （（ _]+ ）。 * 格式（在 Cloud Insights 中）： \1-\2-\3



=== 示例 13

在此示例中，存储别名以 "\" 分隔，表达式需要使用 "\\" 来定义字符串中实际正在使用 "\" ，而这些字符串不属于表达式本身。

* 存储别名： * \hosts\E2DOC01C1\E2DOC01N1

* 主机名： * E2DOC01N1

* 注册时间： * \\.* ？ \\.* ？ \ （ .* ？）



=== 示例 14

此示例从分区示例中提取了 "PD-RV-W-AD-2" 。

* 分区： * pd_D-PD-RV-W-AD-2_01

* 主机名： * pd-rv-W-AD-2

* 正则表达式： * [^ -]+- （ .* - \d+ ） .*



=== 示例 15

在这种情况下，格式设置会将 "US-BV- " 添加到主机名中。

* 分区： * SRV_USVM11_F1

* 主机名： * US-BV-M11

* 注册时间： * SRV_USBV （ [A-ZA-Z0-9]+ ） _F[12]

* 格式： * US-BV-\1.
